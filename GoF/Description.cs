using System;
using System.Collections.Generic;
using System.Text;

namespace GoF
{
    class Description
    {
        /*
                                                            Creational patterns


        Factory method:
        1. Коли створення об'єкта занадто об'ємне сильно роздувається конструктор, тому краще винести створення об'єкта в фабрику.
        2. Коли потрібно створити однотипні елементи із різними данними.

        • Когда заранее неизвестно, объекты каких типов необходимо создавать;
        • Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать;
        • Когда создание новых объектов необходимо делегировать из базового класса классам наследникам;

        1) Більшість архітектур спочатку використовують Factory method, потім переходять до Abstract factory або Builder.
        2) Abstract factory частіше використовують із Factory method або із Builder.
        3) Можна використовувати із Iterator, щоб підкласи колекції могли створювати потрібний їм Iterator.
        4) Можна розглядати як окремий випадок Template Method.



        Abstract factory:
        1. Коли потрібно створити групу однотипних елементів із різними данними, які пов'язані між собою.
        
        • Когда система не должна зависеть от способа создания новых объектов
        • Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными
        
        1) Більшість архітектур спочатку використовують Factory method, потім переходять до Abstract factory або Builder.
        2) Abstract factory частіше використовують із Factory method або із Builder.
        3) Може працювати разом із Bridge. Особливо коли є абстракції, які можуть працювати тільки із деякими реалізаціями. Тоді фабрика буде визначати їхні типи.



        Builder:
        1. Коли створення об'єкту занадто складне із багатьма if.
        
        • Когда процесс создания нового объекта не должен зависеть от того, из каких частей этот объект состоит и как эти части связаны между собой
        • Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания
        
        1) Більшість архітектур спочатку використовують Factory method, потім переходять до Abstract factory або Builder.
        2) Дозволяє покроково створити Composite tree.
        3) Може бути створений у вигляді Bridge. Director - абстракція, Builder - реалізація.



        Prototype:
        1. Коли створення копії об'єкта є доцільним.

        • Класс порождаемого объекта определяется в момент выполнения.
        • Когда желательно избежать наследования создателя объекта. В этом случае, Прототип является конкурентом Абстрактной фабрики.
        • Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация с помощью конструктора.
        • Когда создание копии объекта проще и быстрее, чем порождение его стандартным путем, используя операцию new и включая инициализацию полей.
        
        1) Архітектура створена за допомогою Composite або Decorator може бути покращена за допомогою Prototype.
        2) Може замінити Memento. Якщо об'єкт, стан якого потрібно зберегти, досить простий, не має активних ссилок на зовнішні ресурси або їх можна легко відновити.



        Singleton:
        1. Коли потрібен один об'єкт в системі

        1) Facade можна зробити Singleton(ом).
        2) Abstract factory, builder, prototype можуть бути реалізовані за допомогою Singleton.



                                                            Structural patterns


        Adapter:
        1. Коли потрібно адаптувати(замінити) один інтерфейс під(на) інший.
        2. Коли потрібно використовувати клас під іншим інтерфейсом.

        • Когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям бизнесс логики.
        • Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы.
        
        1) Adapter надає інший інтерфейс, Proxy надає той самий інтерфейс, Decorator надає розширений інтерфейс.
        2) Навідміну від Bridge, Adapter створюється постфактум.



        Proxy:
        1. Коли потрібно розширити клас не змінюючи його.

        • «Заместитель» является одним из немногих паттернов проектирования, который с течением времени претерпел довольно серьезные изменения. В классическом труде «банды четырех» описаны три основных сценария использования паттерна «Заместитель».
        • Удаленный заместитель (remote proxies) — ​отвечает за кодирование запроса и его аргументов для работы с компонентом в другом адресном пространстве.
        • Виртуальный заместитель (virtual proxies) —​ может кэшировать дополнительную информацию о реальном компоненте, чтобы отложить его создание.
        • Защищающий заместитель (protection proxies) — проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права.​ 
        
        • Структуры паттернов «Заместитель» и «Декоратор» очень похожи. Каждый из них содержит ссылку на базовый компонент и делегирует ему выполнение всей работы. Но у этих паттернов разное назначение.​
        • Декоратор добавляет поведение всем методам интерфейса, позволяя нанизывать расширения одно на другое. Класс-заместитель может выполнять определенные действия, например создавать настоящий компонент по мере необходимости, но он не должен ничего "подмешивать" в результаты исполнения операции.
        
        1) Adapter надає інший інтерфейс, Proxy надає той самий інтерфейс, Decorator надає розширений інтерфейс.



        Decorator:
        1. Коли потрібно динамічно додати класу новий функціонал.

        • Когда надо динамически добавлять к объекту новые функциональные возможности. При этом данные возможности могут быть сняты с объекта
        • Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. Еще больше она может разрастись, если нам необходимо создать классы, реализующие все возможные сочетания добавляемых функциональностей.
        
        1) Adapter надає інший інтерфейс, Proxy надає той самий інтерфейс, Decorator надає розширений інтерфейс.



        Bridge:
        1. Коли виникає потреба у створенні потвійної ієрархії.
        2. Коли абстракцію і реалізацію потрібно змінювати незалежно один від одного.

        • Когда надо избежать постоянной привязки абстракции к реализации
        • Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. То есть изменения в абстракции не должно привести к изменениям в реализации
        
        1) Abstract factory може працювати разом із Bridge. Особливо коли є абстракції, які можуть працювати тільки із деякими реалізаціями. Тоді фабрика буде визначати їхні типи.
        2) Builder може бути створений у вигляді Bridge. Director - абстракція, Builder - реалізація.



        Composite:
        1. Створення набору об'єктів у вигляді дерева.
        2. Коли всі об'єкти в ієрархії реалізують один інтерфейс.

        • Когда объекты должны быть реализованы в виде иерархической древовидной структуры
        • Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. То есть целое и его части должны реализовать один и тот же интерфейс
        
        1) Builder дозволяє покроково створити Composite tree.
        2) Можна пройти по дереву використовуючи Iterator.
        3) Можна виконати якусь дію над всім деревом за допомогою Visitor.
        4) Часто використовують із Flyweigh щоб створити гілки, які часто використовуються, щоб зекономити пам'ять.



        Facade:
        1. Коли є складна логіка в класі, яку потрібно інкапсулювати і (або) створити фасад, який згрупує методи.

        • Когда имеется сложная система, и необходимо упростить с ней работу. Фасад позволит определить одну точку взаимодействия между клиентом и системой.
        • Когда надо уменьшить количество зависимостей между клиентом и сложной системой. Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
        • Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга.
        
        1) Facade можна зробити Singleton(ом).



        Flyweight:
        1. Коли в програмі є багато однакових елементів.
        2. Кешування.

        • в приложении используется большое число очень схожих экземпляров заданного класса;
        • (и) часть состояния объекта является контекстной и может быть легко вынесена во внешние структуры;
        • (и) после вынесения части состояния, все экземпляры становятся одинаковыми и это дает возможность заменить их одним;
        • (и) приложение не проверяет идентичность объектов, т.к. в этом случае все якобы самостоятельные экземпляры являются одним объектом.
        
        1) Створення часто використовують із Flyweight щоб створити гілки, які часто використовуються, щоб зекономити пам'ять.





                                                            Behavioral patterns


        Mediator:
        1. Для спрощення міжкласових залежностей.

        • Когда имеется множество взаимосвязаных объектов, связи между которыми сложны и запутаны.
        • Когда необходимо повторно использовать объект, однако повторное использование затруднено в силу сильных связей с другими объектами.



        Chain of responsibility:
        1. Коли потрібно виконати будь-яку із заданих дій

        • Когда имеется более одного объекта, который может обработать определенный запрос;
        • Когда надо передать запрос на выполнение одному из нескольких объект, точно не определяя, какому именно объекту;
        • Когда набор объектов задается динамически.



        Command:
        1. Для інкапсулювання методів і необхідних для них даних.
        2. Для створення об'єкта із методом, який можна передати як параметр.
        3. Додаткова прослойка із бізнес-логіки.

        • Когда необходимо обеспечить выполнение очереди запросов, а также их возможную отмену.
        • Когда надо поддерживать логгирование изменений в результате запросов. Использование логов может помочь восстановить состояние системы - для этого необходимо будет использовать последовательность запротоколированных команд.
        • Когда необходимо параметризировать объекты выполняемым действием, ставить запросы в очередь или поддерживать операции отмены (undo) и повтора (redo) действий.

        1) Command із Memento можна використовувати разом для відміни операції. Command - буде виконувати операцію, Memento - буде зберігати копію стану об'єкта, зроблену перед самим запуском команди.



        Interpreter:
        1. Коли потрібно інтерпретувати одні дані в інші.

        • Интерпретатор следует использовать когда вам  необходимо интерпретировать запись в другом языке и тд. Как один из примеров может служить перевод римских цифр в арабские.



        Iterator:
        1. Для перебору даних.
        2. Коли в об'єкті є більше 2 переборів.
        3. Коли перебор є специфічним.

        • Когда необходимо осуществить обход объекта без раскрытия его внутренней структуры;
        • Когда имеется набор составных объектов, и надо обеспечить единый интерфейс для их перебора;
        • Когда необходимо предоставить несколько альтернативных вариантов перебора одного и того же объекта;
        
        1) Можна пройти по дереву Composite.
        2) Factory method можна використовувати із Iterator, щоб підкласи колекції могли створювати потрібний їм Iterator.
        3) Memento можна використовувати разом із Iterator, щоб зберегти поточний стак обходу структури даних і повенутись до нього в майбутньому, якщо він буде потрібний.
        4) Visitor можна використовувати разом із Iterator. Iterator буде виконувати обхід даних, а Visitor виконання дій над кожним компонентом.



        Memento:
        1. Для зберігання (будь-яких або інкапсульованих) даних в історії і можливості їх відновлення.

        • Когда нужно сохранить состояние объекта для возможного последующего восстановления;
        • Когда сохранение состояния должно проходить без нарушения принципа инкапсуляции;

        1) Command із Memento можна використовувати разом для відміни операції. Command - буде виконувати операцію, Memento - буде зберігати копію стану об'єкта, зроблену перед самим запуском команди.
        2) Memento можна використовувати разом із Iterator, щоб зберегти поточний стак обходу структури даних і повенутись до нього в майбутньому, якщо він буде потрібний.
        3) Prototype може замінити Memento. Якщо об'єкт, стан якого потрібно зберегти, досить простий, не має активних ссилок на зовнішні ресурси або їх можна легко відновити.



        Observer:
        1. Коли декілька об'єктів повинні слідкувати за іншим об'єктом і реагувати на його зміну.

        • Когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
        • Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
        • Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и процессе работы программы может изменяться.



        State:
        1. Коли поведінка об'єкту залежить від його внутрішнього стану та коли цих станів багато і їх код може змінюватись.

        • Когда поведение объекта должно зависеть от его состояния и может изменяться динамически во время выполнения
        • Когда в коде методов объекта используются многочисленные условные конструкции, выбор которых зависит от текущего состояния объекта



        Strategy:
        1. Дозволяє використовувати композицію замість наслідування.

        • Когда есть несколько схожих классов , которые отличаются поведением. Можно задать один основной класс, а разные варианты поведения вынести в отдельные классы и при необходимости их применять;
        • Когда необходимо обеспечить выбор из нескольких вариантов решений, которые можно легко менять в зависимости от условий;
        • Когда необходимо менять поведение классов и объектов на стадии выполнения программы;
        • Когда класс, применяющий определенную функциональность, ничего не должен знать о ее реализации



        Template method:
        1. Коли класи можуть змінювати алгоритм.
        2. Коли є базовий алгоритм виконання, частини якого потрібно змінювати залежно від ситуації.

        • Когда планируется, что в будущем подклассы должны будут переопределять различные этапы алгоритма без изменения его структуры
        • Когда в классах, реализующим схожий алгоритм, происходит дублирование кода. Вынесение общего кода в шаблонный метод уменьшит его дублирование в подклассах.
        


        Visitor:
        1. Коли потрібно додати нову функціональність класу не змінюючи його.
        
        • Паттерн Посетитель определяет операцию, выполняемую на каждом элементе из некоторой структуры. Позволяет, не изменяя классы этих объектов, добавлять в них новые операции.
        • Является классической техникой для восстановления потерянной информации о типе.
        • Паттерн Посетитель позволяет выполнить нужные действия в зависимости от типов двух объектов.
        • Предоставляет механизм двойной диспетчеризации.



        */
    }
}
